// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mwebd.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The height of the latest block.
  var blockHeaderHeight: Int32 = 0

  /// The height of the latest MWEB header.
  var mwebHeaderHeight: Int32 = 0

  /// The height at which the MWEB utxo set is synced to.
  var mwebUtxosHeight: Int32 = 0

  /// The timestamp of the latest block.
  var blockTime: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UtxosRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block height from which to start fetching utxos from.
  /// After all mined utxos have been streamed, unconfirmed and
  /// newly confirmed utxos will also be streamed. If this is set
  /// to 0 then all utxos belonging to the account will be fetched.
  var fromHeight: Int32 = 0

  /// The scan secret or view key represents the account for
  /// which utxos should be streamed.
  var scanSecret: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Utxo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block height of the utxo, or 0 for unconfirmed.
  var height: Int32 = 0

  /// The value of the utxo in litoshis.
  var value: UInt64 = 0

  /// The MWEB address that the utxo was received on.
  var address: String = String()

  /// The output ID. This functions like a transaction hash,
  /// but is unique to every utxo.
  var outputID: String = String()

  /// The timestamp of the block the utxo was mined in.
  var blockTime: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AddressRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The starting index of the range.
  var fromIndex: UInt32 = 0

  /// The ending index of the range. The result will contain all
  /// addresses up to but not including this index.
  var toIndex: UInt32 = 0

  /// The scan secret or view key represents the account for
  /// which addresses should be returned.
  var scanSecret: Data = Data()

  /// The public key of the spend secret for the account. The spend
  /// key is required for spending utxos but is also required
  /// for generating addresses.
  var spendPubkey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AddressResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of MWEB addresses within the requested range.
  var address: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LedgerApdu: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of output IDs to perform checks for.
  var outputID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An array of the output IDs that were not found in the
  /// unspent set. This means that the outputs are either
  /// unconfirmed or were spent.
  var outputID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw bytes of the serialized transaction. This will be
  /// a template where the non-MWEB inputs will remain unchanged,
  /// and the MWEB inputs are specified by TxIns with the outpoint
  /// hash set to the output ID of the utxo being spent, and the
  /// outpoint index set to the index of the address that the utxo
  /// was received on. MWEB outputs are specified by TxOuts with
  /// the script pubkey set to the serialized scan and spend pubkeys
  /// of the destination MWEB address. Any non-MWEB outputs will be
  /// transformed into MWEB peg-outs. If the transaction doesn't
  /// contain any MWEB i/o then the result will be unchanged.
  var rawTx: Data = Data()

  /// The scan secret or view key represents the account that
  /// the utxos being spent belong to.
  var scanSecret: Data = Data()

  /// The spend secret is the private key necessary for spending
  /// the utxos belonging to the account.
  var spendSecret: Data = Data()

  /// The fee rate per KB in litoshis.
  var feeRatePerKb: UInt64 = 0

  /// Whether to skip MWEB transaction creation. This is useful
  /// for fee estimation.
  var dryRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw bytes of the serialized transaction. It will contain
  /// a single TxOut representing the peg-in required. From this
  /// it is possible to determine the addtional fee that was added
  /// by the MWEB transaction.
  var rawTx: Data = Data()

  /// The output IDs of any utxos created by the transaction,
  /// in the same order as in the template.
  var outputID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BroadcastRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw bytes of the serialized transaction.
  var rawTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BroadcastResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction ID.
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinswapRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The scan secret or view key represents the account that
  /// the utxo belongs to.
  var scanSecret: Data = Data()

  /// The spend secret is the private key necessary for spending
  /// the utxos belonging to the account.
  var spendSecret: Data = Data()

  /// Output ID of the utxo to request a coinswap for.
  var outputID: String = String()

  /// Address index of the utxo.
  var addrIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinswapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output ID of the utxo created by the transaction.
  var outputID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatusRequest, rhs: StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_header_height"),
    2: .standard(proto: "mweb_header_height"),
    3: .standard(proto: "mweb_utxos_height"),
    4: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.blockHeaderHeight) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mwebHeaderHeight) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.mwebUtxosHeight) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockHeaderHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.blockHeaderHeight, fieldNumber: 1)
    }
    if self.mwebHeaderHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.mwebHeaderHeight, fieldNumber: 2)
    }
    if self.mwebUtxosHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.mwebUtxosHeight, fieldNumber: 3)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatusResponse, rhs: StatusResponse) -> Bool {
    if lhs.blockHeaderHeight != rhs.blockHeaderHeight {return false}
    if lhs.mwebHeaderHeight != rhs.mwebHeaderHeight {return false}
    if lhs.mwebUtxosHeight != rhs.mwebUtxosHeight {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UtxosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UtxosRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_height"),
    2: .standard(proto: "scan_secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fromHeight) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.scanSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.fromHeight, fieldNumber: 1)
    }
    if !self.scanSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.scanSecret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UtxosRequest, rhs: UtxosRequest) -> Bool {
    if lhs.fromHeight != rhs.fromHeight {return false}
    if lhs.scanSecret != rhs.scanSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Utxo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Utxo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "value"),
    3: .same(proto: "address"),
    4: .standard(proto: "output_id"),
    5: .standard(proto: "block_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outputID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.blockTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if !self.outputID.isEmpty {
      try visitor.visitSingularStringField(value: self.outputID, fieldNumber: 4)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.value != rhs.value {return false}
    if lhs.address != rhs.address {return false}
    if lhs.outputID != rhs.outputID {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AddressRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_index"),
    2: .standard(proto: "to_index"),
    3: .standard(proto: "scan_secret"),
    4: .standard(proto: "spend_pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.fromIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.toIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.scanSecret) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.spendPubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fromIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.fromIndex, fieldNumber: 1)
    }
    if self.toIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.toIndex, fieldNumber: 2)
    }
    if !self.scanSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.scanSecret, fieldNumber: 3)
    }
    if !self.spendPubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.spendPubkey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AddressRequest, rhs: AddressRequest) -> Bool {
    if lhs.fromIndex != rhs.fromIndex {return false}
    if lhs.toIndex != rhs.toIndex {return false}
    if lhs.scanSecret != rhs.scanSecret {return false}
    if lhs.spendPubkey != rhs.spendPubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AddressResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AddressResponse, rhs: AddressResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LedgerApdu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LedgerApdu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LedgerApdu, rhs: LedgerApdu) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SpentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.outputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpentRequest, rhs: SpentRequest) -> Bool {
    if lhs.outputID != rhs.outputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SpentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.outputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpentResponse, rhs: SpentResponse) -> Bool {
    if lhs.outputID != rhs.outputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
    2: .standard(proto: "scan_secret"),
    3: .standard(proto: "spend_secret"),
    4: .standard(proto: "fee_rate_per_kb"),
    5: .standard(proto: "dry_run"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.scanSecret) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.spendSecret) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.feeRatePerKb) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    if !self.scanSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.scanSecret, fieldNumber: 2)
    }
    if !self.spendSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.spendSecret, fieldNumber: 3)
    }
    if self.feeRatePerKb != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeRatePerKb, fieldNumber: 4)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreateRequest, rhs: CreateRequest) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.scanSecret != rhs.scanSecret {return false}
    if lhs.spendSecret != rhs.spendSecret {return false}
    if lhs.feeRatePerKb != rhs.feeRatePerKb {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
    2: .standard(proto: "output_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.outputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    if !self.outputID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreateResponse, rhs: CreateResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.outputID != rhs.outputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BroadcastRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BroadcastRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BroadcastRequest, rhs: BroadcastRequest) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BroadcastResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BroadcastResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BroadcastResponse, rhs: BroadcastResponse) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinswapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoinswapRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scan_secret"),
    2: .standard(proto: "spend_secret"),
    3: .standard(proto: "output_id"),
    4: .standard(proto: "addr_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.scanSecret) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spendSecret) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outputID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.addrIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scanSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.scanSecret, fieldNumber: 1)
    }
    if !self.spendSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.spendSecret, fieldNumber: 2)
    }
    if !self.outputID.isEmpty {
      try visitor.visitSingularStringField(value: self.outputID, fieldNumber: 3)
    }
    if self.addrIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.addrIndex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinswapRequest, rhs: CoinswapRequest) -> Bool {
    if lhs.scanSecret != rhs.scanSecret {return false}
    if lhs.spendSecret != rhs.spendSecret {return false}
    if lhs.outputID != rhs.outputID {return false}
    if lhs.addrIndex != rhs.addrIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinswapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoinswapResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputID.isEmpty {
      try visitor.visitSingularStringField(value: self.outputID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinswapResponse, rhs: CoinswapResponse) -> Bool {
    if lhs.outputID != rhs.outputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
